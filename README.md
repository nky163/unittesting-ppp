
# 第１章 なぜ単体テストを行うのか
## なぜ単体テストを行うのか
- 第一の目標は、ソフトウェアプロジェクトを**持続可能**なものにする、ということ
	- 一般的に、テストがない場合、プロジェクトが大きくなるにつれ、変更に費やす時間は指数関数的に増えていく
		- 一つのバグを修正するのにより多くのバグを見出すことになったりする
	- テストを用意することでコードの変更によるリグレッションを検出するセーフティネットがプロジェクトに備わることになる
	- 新しい機能が追加したり、新たな要求を満たすためのリファクリングに費やすコストを減らせる
- テストの欠点は、テストを用意するのに最初はそれなりの労力を必要とするところ
	- 長い目で見れば、プロジェクトの成長を支援することになるので、後でその労力が報われることになる
- プロジェクトの成長を持続できるようにするには、質の良いテストケースだけを集める必要がある
	- 質の悪いテストケースが多くなると、目標を達成できない
	- 単体テストの価値とその維持にかかるコストの両方を考慮しなければならない
		- コストよりも価値のほうが高いテストスイートを残すことが重要
	- 良い単体テストと悪い単体テストの違いを学ぶことは開発者にとって必要不可欠(第4章で)

## 網羅立とテストスイートの質の関係
- 網羅率では、テストスイートの**質**を評価することはできない
	- 網羅率100％ならば質の良いテスト、とは断言できない
- 理由
	- 網羅率からは実際にテスト対象のコードが検証されたのかを保証できないため
		- コードが実行されるだけでなく、実際に検証されなければテストの目的を果たさない
	- 網羅率を計算する際、使用するライブラリ内のコードは計測の対象から外れるため
- 網羅率の結果に縛られること
	- 開発者を網羅率の数値で縛ると、開発を妨げる危険なものとなることがある
		- たとえ70％とかであっても
	- テストの内容について考えることの妨げになる
	- 網羅率を目標にするのではなく、テストが十分に行われていないことを示す１つの指標として見る必要がある

## 何がテストスイートの質を良くするのか
- 優れたテストスイートの特徴
	- テストすることが開発のサイクルに組み込まれている
		- 理想はコードに変更を加えるたびにテストが実施される状態
	- コードベースの特に重要な部分のみがテスト対象となっている
		- テストによってもたらされる価値は、テスト自体ではなく検証されるコードにある
		- 重要な部分とは、ビジネスロジック、つまり**ドメインモデル**の部分
		- なので、ドメインモデルをコードベースの本質てきでない部分から隔離しておかなければならない(第２部で)
	- 最小限の保守コストで最大限の価値を生み出すようになっている
		- これを実現するには、以下の２つのことを行えなくてはならない
			- 価値のあるテストケースを認識できること
			- 価値のあるテストケースを作成できること
				- そのためには、テスト対象のコードベースが良い設計であることが必要なので、設計のスキルも必要


# 第２章 単体テストとは何か
## 単体テストの定義
- 単体テストの３つの性質
	- 少量のコードを検証する
	- 実行時間が短い
	- 隔離された状態で実行する
## 古典学派およびロンドン学派が考える単体テスト
- **隔離**に関する見解の違いがある
	- ロンドン学派
		- テスト対象となるクラスが他のクラスに依存しているのであれば、その依存をテストダブルに置き換えるべき、という考え
		- テストが失敗したときに、対象オブジェクトで問題が起こったことを明確にできる
		- 複雑なオブジェクトグラフを分離できる
		- １つのテストケースで１つのクラスを検証できる
		- 基本的に全ての依存をテストダブルに置き換える
	- 古典学派
		- コードではなく、**テストケース**を隔離するという考え
		- 実行されるテストケースが他のテストケースに影響を与えることがないようにする（テストが並行に走っても良いようにする）
		- データベースやファイルシステムなどの共有依存だけをテストダブルに置き換える
			- 共有依存への呼び出しは実行時間が長くなるため、統合テストに含める必要がある
		- モックなどのテストダブルがロンドン学派よりも少なくなる

	|    |  隔離対象  |  単体の意味  |  テストダブルの置き換え対象  |
	| ---- | ---- | ---- | ---- |
	|  ロンドン学派  |  単体  |  １つのクラス  |  不変依存を除くすべての依存  |
	|  古典学派  |  テストケース  |  １つのクラス、もしくは、同じ目的を達成するためのクラスのグループ  |  共有依存  |

- ロンドン学派と古典学派の比較
	- 筆者は古典学派の考え方を推している
	- ロンドン学派の以下がメリットとして言われているが、古典学派の観点から見た時にはあまりメリットとは言えない
		- 細かい粒度で検証ができる(１クラス１テストケース)、、、
			- 単体テストでは１単位のコードを検証するのではなく、**１単位の振る舞いを検証するのが質が良いテスト**といえる
			- ここで意味する単体は複数のクラスにまたがることもありうる
			- 単体テストにおいて、各テストケースがすべきことは
				- **そのテストに関わる人たちにテスト対象のコードが何を解決しようとしているかを伝えること**
				- そのためには、非開発者でも理解できるようにすることが必要
				- 詳しくは第５章で
		- 依存関係が複雑になってもテストができる、、、
			- 本来考えるべきことは、膨大で複雑な依存関係を持つクラスを検証するための方法ではなく、
				- そのような複雑な依存関係を構築しなくても住むようにするための方法
			- ほとんどの場合、複雑な依存関係が必要になってしまう誤った設計になっている
		- テストが失敗したとき、どの機能に問題があったか正確に見つけることができる、、、
			- 古典学派の単体テストでもあっても、頻繁にテストを実施していれば、最後に変更した箇所にバグがあることを特定できる
- 古典学派とロンドン学派のテスト駆動開発
	- ロンドン学派
		- 外側から内側へのTDD
		- まずシステム全体がどのように機能するかを考えた広い視野でテストケースを考える
		- 内側をモックを使って、外側のクラスから実装していく
		- **テストが実装の詳細に深く結びつく**ので壊れやすいテストになる
	- 古典学派
		- 内側から外側へのTDD
		- 古典学派では共有依存以外はモックを使わないので、核となるドメインモデルからテストと実装を行う
		- その後に上の層のテストと実装を追加していく
## 古典学派及びロンドン学派における統合(integration)テスト
- **(本書では古典学派の定義を採用している)**
- ロンドン学派
	- 協力者オブジェクトを使って行うテストを統合テストとみなす
	- 古典学派のスタイルで書かれた単体テストはロンドン学派の視点だと統合テストに分類される
- 古典学派
	- 古典学派が考える統合テストは、古典学派が考える単体テストの性質を損なっているもの
	- 古典学派が考えるテストの性質は
		- １単位の振る舞いを検証すること
		- 実行時間が短いこと
		- 他のテストケースから隔離された状態で実行されること
- （統合テストについては第３部で詳しく、、）
- E2Eテスト
	- 統合テストの一種と考えられる
	- 統合テストとの違いは、E2Eの方がプロセス外依存を多く含むようになること
		- 明確な基準はないが、一般的に
			- 統合テストは１個か２個のプロセス外依存を扱う
			- E2Eテストは全てのプロセス外依存を扱う（エンドユーザの視点でシステムを検証するから）
			- 統合テストは、開発者が完全に制御できない外部サービス(決済サービスとか)はテストダブルを用意する
	- E2Eテストは保守にコストがかかるので、全ての単体テストと統合テストが成功するようになった後に実施する(ビルドサーバでのみ実施するとか)
```
public void Purchase_succeeds_when_enough_inventory() {
	// 準備
	var store = new Store();
	store.AddInventory(Product.Shampoo, 10);
	var customer = new Customer();
	
	// 実行
	bool success = customer.Purchase(store, Product.Shampoo, 5);
	
	// 確認
	Assert.True(success);
	Assert.Equal(5, store.GetInventory(Product.Shampoo));
}
```

```
public void Purchase_succeeds_when_enough_inventory() {
	// 準備
	var storeMock = new Mock<IStore>();;
	storeMock
		.Setup(x => x.HasEnoughInventory(Product.Shampoo, 5))
		.Returns(true);
	var customer = new Customer();
	
	// 実行
	bool success = customer.Purchase(storeMock.Object, Product.Shampoo, 5);
	
	// 確認
	Assert.True(success);
	storeMock.Verify(
		x => x.RemoveInventory(Product.Shampoo, 5),	 // このメソッドが１回呼ばれる
		Times.Once);
}
```


# 第３章 単体テストの構造
## 単体テストの構造
- AAAパターン
	- Arrange(準備)
	- Act(実行)
	- Assert(確認)
- テスト駆動開発の場合、Assertから書き始めることで、その機能の振る舞いの見通しが立てやすい
- 単体テストにおいて回避すべきこと
	- 同じフェーズを複数用意すること
		- 準備 -> 実行 -> 確認 -> 別の実行 -> 別の確認
		- これは２つの振る舞いをテストしようとしているので、２つのテストケースに分けるべき
		- テストの目的が分かりにくくなる
	- if文の仕様
		- 単体テストであれ統合テストであれ分岐のない流れにする必要がある
		- テストケースを分割すべき
- 各フェーズ(AAA)の長さ
	- Act(実行)が２行以上になる場合は設計がおかしいかも
		- カプセル化が破綻していないか確認する必要がある
- テストの後始末
	- 単体テストでは、ほとんどの場合、後始末の処理を必要としない
		- 単体テストでは、プロセス外依存とのやり取りは行わないので、破棄しなくてはならないものは残らない
	- 後始末が必要になるのは統合テスト
## 単体テストのフレームワークについて
- **各テストケースは、プロダクションコードが解決しようとしている物語について語るべき**
	- 単体テストでテストべきはプロダクションコードがすることを列挙するのではなく
	- アプリケーションの振る舞いについてより高いレベルで描写すること
	- **理想的には、非開発者にも伝わるようにテストコードを書く**
- テストフィクスチャの準備は慎重に
	- テストケース間で共有しないようにする
		- テストケース間のつながりが強くなるので
		- 個々のテストケースで、準備のフェーズが見えないので、何を検証しているのか分かりにくくなる
	- テストクラスにプライベートなファクトリメソッドを用意してテストケースで呼び出すようにすると良い感じに
	
## 単体テストでの名前のつけ方
- 何を検証するかを明確に説明するために、テストメソッドの名前のつけ方は超重要
- 非常に有名で、おそらく最も役に立たない命名規則↓
	- {テスト対象メソッド名}\_{事前準備}\_{想定する結果}
		- eg) public void Sum_TwoNumbers_ReturnsSum()
	- 振る舞いではなく、実装の詳細に注目しているからダメ
	- 非開発者が見ても分かるような名前にすべき
- テストメソッドに名前を付けるときの指針
	- 厳格な命名規則に縛られないようにする
		- テスト対象の振る舞いに応じて簡潔な言い回しで命名する
	- **非開発者にどのような検証をするのか伝わるように**
	- (英語の場合)アンダースコアを使って単語を区切る
		- 名前が長い時に読みやすくなる
- テスト対象のメソッド名をテストメソッド名に含めるべきでない理由
	- 単体テストはコードをテストしているわけではなく、**単一の振る舞いをテストしているから**
	- テスト対象のメソッド名はテスト対象の振る舞いの入口に過ぎない
	- ただしユーティリティ系のコードをテストする場合は、例外的にＯＫ
		- ユーティリティ系のコードにはビジネスロジックは含まれていないので


## パラメータ化テストへのリファクタリング
- パラメータ化テスト
	- １つの振る舞いを検証するために、複数のテストケースが必要な場合、１つのテストメソッドでテストを簡潔に書くことができる
## Assertフェーズの読みやすさの改善
- Assertionライブラリを使おう
# 第４章 良い単体テストを構成する４本の柱
## 良い単体テストを構成する４本の柱
## リグレッションに対する保護とリファクタリングへの体制との関係
## 迅速なフィードバックと保守のしやすさ
## 理想的なテストの探求
## ソフトウェア・単体テストにおける良く知られた概念

# 第５章 モックの利用とテストの壊れやすさ
## モックとスタブの違い
## 観察可能な振る舞いと実装の詳細
## モックの利用とテストの壊れやすさの関係
## 振り返り：単体テストの古典学派とロンドン学派の違い

# 第６章 単体テストの３つの手法
## 単体テストの３つの手法
## 単体テストの３つの手法の比較
## 関数型アーキテクチャについて
## 関数型アーキテクチャおよび出力値ベーステストへの移行
## 関数型アーキテクチャの欠点

# 第７章 単体テストの価値を高めるリファクタリング
## リファクタリングが必要なコードの識別
## 単体テストに価値を持たせるためのリファクタリング
## プロダクションコードの種類に基づく効果的な単体テストの作成
## コントローラにおける条件付きロジックの扱い
## 結論

# 第８章 なぜ統合(integration)テストを行うのか
## 統合テストとは
## どのようなプロセス外依存をモックに置き換えるべきか
## どのように統合(integration)テストを行うのか
## インターフェースを使った依存の抽象化
## 統合テストのベストプラクティス
## ログ出力に対するテスト
## 結論

# 第９章 モックのベストプラクティス
## モックの価値を最大限に引き出す方法
## モックのベストプラクティス

# 第10章 データベースに対するテスト
## データベースをテストするのに必要な事前準備
## データベーストランザクションの管理
## テストデータのライフサイクル
## テストコードの再利用
## データベースを使ったテストに関するよくある疑問

# 第11章 単体テストのアンチパターン
## プライベートなメソッドに対する単体テスト
## プライベートな状態を公開
## テストへのドメイン知識の漏洩
## プロダクションコードへの汚染
## 具象クラスに対するテストダブル
## 単体テストに置ける現在時刻の扱い
## 結論

# メモ
- 説明できるというスキルは非常に重要
	- 自分の考えを他人に明確に伝えられることは価値のある能力であるから
- 単体テストと設計の関係
	- テストをしにくいプロダクションコードは、設計がよくないことが多い
		- コード同士が密結合になっていることで、コードを分離して個別でテストするのが難しい
	- ただし単体テストを作成しやすいからと言って、プロダクションコードに質がいい、と判断することはできない


- 以下の問いに答えられるように
	- テスト対象となるプロダクションコードとともに、テストスイートをリファクタリングするにはどうすればよいか？
	- 異なる手法の単体テストをどのように適用するのか？
	- どのように統合テストを使って、システムの全体の振る舞いを検証するのか
	- 単体テストにおけるアンチパターンをどのように識別し、それを回避するのか