
# 第１章 なぜ単体テストを行うのか
## なぜ単体テストを行うのか
- 第一の目標は、ソフトウェアプロジェクトを**持続可能**なものにする、ということ
	- 一般的に、テストがない場合、プロジェクトが大きくなるにつれ、変更に費やす時間は指数関数的に増えていく
		- 一つのバグを修正するのにより多くのバグを見出すことになったりする
	- テストを用意することでコードの変更によるリグレッションを検出するセーフティネットがプロジェクトに備わることになる
	- 新しい機能が追加したり、新たな要求を満たすためのリファクリングに費やすコストを減らせる
- テストの欠点は、テストを用意するのに最初はそれなりの労力を必要とするところ
	- 長い目で見れば、プロジェクトの成長を支援することになるので、後でその労力が報われることになる
- プロジェクトの成長を持続できるようにするには、質の良いテストケースだけを集める必要がある
	- 質の悪いテストケースが多くなると、目標を達成できない
	- 単体テストの価値とその維持にかかるコストの両方を考慮しなければならない
		- コストよりも価値のほうが高いテストスイートを残すことが重要
	- 良い単体テストと悪い単体テストの違いを学ぶことは開発者にとって必要不可欠(第4章で)

## 網羅立とテストスイートの質の関係
- 網羅率では、テストスイートの**質**を評価することはできない
	- 網羅率100％ならば質の良いテスト、とは断言できない
- 理由
	- 網羅率からは実際にテスト対象のコードが検証されたのかを保証できないため
		- コードが実行されるだけでなく、実際に検証されなければテストの目的を果たさない
	- 網羅率を計算する際、使用するライブラリ内のコードは計測の対象から外れるため
- 網羅率の結果に縛られること
	- 開発者を網羅率の数値で縛ると、開発を妨げる危険なものとなることがある
		- たとえ70％とかであっても
	- テストの内容について考えることの妨げになる
	- 網羅率を目標にするのではなく、テストが十分に行われていないことを示す１つの指標として見る必要がある

## 何がテストスイートの質を良くするのか
- 優れたテストスイートの特徴
	- テストすることが開発のサイクルに組み込まれている
		- 理想はコードに変更を加えるたびにテストが実施される状態
	- コードベースの特に重要な部分のみがテスト対象となっている
		- テストによってもたらされる価値は、テスト自体ではなく検証されるコードにある
		- 重要な部分とは、ビジネスロジック、つまり**ドメインモデル**の部分
		- なので、ドメインモデルをコードベースの本質てきでない部分から隔離しておかなければならない(第２部で)
	- 最小限の保守コストで最大限の価値を生み出すようになっている
		- これを実現するには、以下の２つのことを行えなくてはならない
			- 価値のあるテストケースを認識できること
			- 価値のあるテストケースを作成できること
				- そのためには、テスト対象のコードベースが良い設計であることが必要なので、設計のスキルも必要


# 第２章 単体テストとは何か
## 単体テストの定義
- 単体テストの３つの性質
	- 少量のコードを検証する
	- 実行時間が短い
	- 隔離された状態で実行する
- 隔離された状態に関する見解の違い
	- ロンドン学派
		- テスト対象となるクラスが他のクラスに依存しているのであれば、その依存をテストダブルに置き換えるべき、という考え
		- テストが失敗したときに、対象オブジェクトで問題が起こったことを明確にできる
		- 複雑なオブジェクトグラフを分離できる
		- １つのテストケースで１つのクラスを検証できる
		- 基本的に全ての依存をテストダブルに置き換えるが、値オブジェクトなど不変なクラスは置き換えなくてもよい
	- 古典学派
		- コードではなく、テストケースを隔離するという考え
		- 実行されるテストケースが他のテストケースに影響を与えることがないようにする
		- データベースやファイルシステムなど共有依存をテストダブルに置き換える
		- モックなどのテストダブルがロンドン学派よりも少なくなる
		- 共有依存への呼び出しは実行時間が長くなるため、インテグレーションテストに含める必要がある

	|    |  隔離対象  |  単体の意味  |  テストダブルの置き換え対象  |
	| ---- | ---- | ---- | ---- |
	|  ロンドン学派  |  単体  |  １つのクラス  |  不変依存を除くすべての依存  |
	|  古典学派  |  テストケース  |  １つのクラス、もしくは、同じ目的を達成するためのクラスのグループ  |  共有依存  |

- ロンドン学派と古典学派の比較
	- 筆者は古典学派の方を推している
	- ロンドン学派の以下がメリットとして言われているが、古典学派の観点から見た時にはメリットとは言えない
		- 細かい粒度で検証ができる(１クラス１テストケース)
			- 単体テストでは１単位のコードを検証するのではなく、１単位の振る舞いを検証するのが質が良いテストといえる
			- ここで意味する単体は複数のクラスにまたがることもありうる
			- 単体テストにおいて、各テストケースがすべきことは
				- **そのテストに関わる人たちにテスト対象のコードが何を解決しようとしているかを伝えること**
				- そのためには、非開発者でも理解できるようにすることが必要
				- 詳しくは第５章で、、
		- 依存関係が複雑になってもテストができる
		- テストが失敗したとき、どの機能に問題があったか正確に見つけることができる
		- 
- Tips
	- 単体テストでは１単位のコードを検証するのではなく、１単位の振る舞いを検証する
	- 理想としては、ビジネス再度の人たちが有用であると考える何か
		
## 古典学派およびロンドン学派が考える単体テスト
## 単体テストにおける古典学派の違い
## 古典学派及びロンドン学派における統合(integration)テスト

# 第３章
## 単体テストの構造
## 単体テストのフレームワークについて
## 単体テストでの名前のつけ方
## パラメータ化テストへのリファクタリング
## Assertフェーズの読みやすさの改善

# 第４章 良い単体テストを構成する４本の柱
## 良い単体テストを構成する４本の柱
## リグレッションに対する保護とリファクタリングへの体制との関係
## 迅速なフィードバックと保守のしやすさ
## 理想的なテストの探求
## ソフトウェア・単体テストにおける良く知られた概念

# 第５章 モックの利用とテストの壊れやすさ
## モックとスタブの違い
## 観察可能な振る舞いと実装の詳細
## モックの利用とテストの壊れやすさの関係
## 振り返り：単体テストの古典学派とロンドン学派の違い

# 第６章 単体テストの３つの手法
## 単体テストの３つの手法
## 単体テストの３つの手法の比較
## 関数型アーキテクチャについて
## 関数型アーキテクチャおよび出力値ベーステストへの移行
## 関数型アーキテクチャの欠点

# 第７章 単体テストの価値を高めるリファクタリング
## リファクタリングが必要なコードの識別
## 単体テストに価値を持たせるためのリファクタリング
## プロダクションコードの種類に基づく効果的な単体テストの作成
## コントローラにおける条件付きロジックの扱い
## 結論

# 第８章 なぜ統合(integration)テストを行うのか
## 統合テストとは
## どのようなプロセス外依存をモックに置き換えるべきか
## どのように統合(integration)テストを行うのか
## インターフェースを使った依存の抽象化
## 統合テストのベストプラクティス
## ログ出力に対するテスト
## 結論

# 第９章 モックのベストプラクティス
## モックの価値を最大限に引き出す方法
## モックのベストプラクティス

# 第10章 データベースに対するテスト
## データベースをテストするのに必要な事前準備
## データベーストランザクションの管理
## テストデータのライフサイクル
## テストコードの再利用
## データベースを使ったテストに関するよくある疑問

# 第11章 単体テストのアンチパターン
## プライベートなメソッドに対する単体テスト
## プライベートな状態を公開
## テストへのドメイン知識の漏洩
## プロダクションコードへの汚染
## 具象クラスに対するテストダブル
## 単体テストに置ける現在時刻の扱い
## 結論

# メモ
- 説明できるというスキルは非常に重要
	- 自分の考えを他人に明確に伝えられることは価値のある能力であるから
- 単体テストと設計の関係
	- テストをしにくいプロダクションコードは、設計がよくないことが多い
		- コード同士が密結合になっていることで、コードを分離して個別でテストするのが難しい
	- ただし単体テストを作成しやすいからと言って、プロダクションコードに質がいい、と判断することはできない


- 以下の問いに答えられるように
	- テスト対象となるプロダクションコードとともに、テストスイートをリファクタリングするにはどうすればよいか？
	- 異なる手法の単体テストをどのように適用するのか？
	- どのように統合テストを使って、システムの全体の振る舞いを検証するのか
	- 単体テストにおけるアンチパターンをどのように識別し、それを回避するのか